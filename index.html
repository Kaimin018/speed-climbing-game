<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFSC Speed Climbing - Smooth Rappel</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #87CEEB; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Header Info */
        #header-info {
            display: flex; justify-content: space-between; padding: 20px 40px; align-items: flex-start;
        }
        .label { font-size: 14px; color: #fff; text-transform: uppercase; letter-spacing: 2px; font-weight: bold; text-shadow: 0 1px 3px rgba(0,0,0,0.5); }

        /* Input Zone */
        #input-zone {
            position: absolute; bottom: 60px; width: 100%;
            display: flex; justify-content: center; align-items: flex-end;
            padding-bottom: 20px;
            transition: opacity 0.5s;
        }
        #current-row-container {
            background: rgba(20, 25, 40, 0.85); padding: 15px 30px;
            border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px); box-shadow: 0 20px 50px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            transition: transform 0.1s;
        }
        #current-row { display: flex; gap: 12px; }
        .key-box {
            width: 60px; height: 60px; border-radius: 12px;
            background: rgba(255, 255, 255, 0.08); border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; color: white; font-weight: bold; transition: all 0.1s;
        }
        .key-box.active {
            border-color: #ff4d4d; background: #ff4d4d;
            box-shadow: 0 0 25px rgba(255, 77, 77, 0.6); transform: scale(1.1);
        }
        .key-box.done { background: #4caf50; border-color: #4caf50; transform: scale(0.85); opacity: 0.6; }

        /* Preview */
        #preview-container {
            position: absolute; bottom: 40px; right: 40px;
            background: rgba(0, 0, 0, 0.3); padding: 15px;
            border-radius: 15px; border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(5px); transition: opacity 0.3s;
        }
        #preview-row { display: flex; gap: 6px; margin-top: 5px; }
        .preview-key {
            width: 25px; height: 25px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.4);
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: rgba(255,255,255,0.9);
        }

        /* Menu */
        #menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.92); backdrop-filter: blur(15px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 20;
        }
        h1 { 
            font-size: 72px; margin: 0; 
            background: linear-gradient(to right, #ff4d4d, #ffdf00);
            -webkit-background-clip: text; background-clip: text;
            -webkit-text-fill-color: transparent; color: transparent;
            font-style: italic; text-transform: uppercase;
        }
        .subtitle { font-size: 24px; color: #94a3b8; margin-bottom: 50px; letter-spacing: 3px; }
        button {
            padding: 20px 60px; font-size: 28px; background: #ff4d4d; color: white;
            border: none; cursor: pointer; font-weight: 900; text-transform: uppercase;
            border-radius: 8px; box-shadow: 0 10px 0 #cc0000; transition: transform 0.1s;
        }
        button:hover { transform: translateY(-2px); background: #ff6666; }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #cc0000; }

        #result-overlay {
            display: none; font-size: 40px; color: #ffdf00; font-weight: bold; 
            margin-bottom: 20px; text-shadow: 0 2px 10px black;
        }

        /* 手機端虛擬方向鍵 */
        #mobile-controls {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: none; pointer-events: auto; z-index: 10;
        }
        /* 桌面端永遠隱藏虛擬方向鍵 */
        @media (min-width: 769px) {
            #mobile-controls { display: none !important; }
        }
        /* 手機端只在遊戲進行時顯示 */
        @media (max-width: 768px) {
            #mobile-controls.active { display: block; }
        }
        .control-pad {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 8px; width: 200px; margin: 0 auto;
        }
        .control-btn {
            width: 60px; height: 60px; border-radius: 12px;
            background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex; align-items: center; justify-content: center;
            font-size: 28px; color: white; font-weight: bold;
            backdrop-filter: blur(10px); user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s;
        }
        .control-btn:active {
            background: rgba(255, 77, 77, 0.6); transform: scale(0.9);
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.5);
        }
        .control-btn.empty { background: transparent; border: none; }

        /* 手機端響應式設計 */
        @media (max-width: 768px) {
            body { touch-action: none; -webkit-user-select: none; user-select: none; }
            
            #header-info { padding: 15px 20px; }
            .label { font-size: 12px; }
            #height-display { font-size: 24px !important; }
            
            /* 手機端：往上移動 sequence 和 next，避免被方向鍵擋住 */
            #input-zone { bottom: 540px; padding-bottom: 10px; }
            #current-row-container { padding: 12px 20px; border-radius: 15px; }
            .key-box { width: 45px; height: 45px; font-size: 24px; }
            
            #preview-container { bottom: 420px; right: 20px; padding: 10px; }
            .preview-key { width: 20px; height: 20px; font-size: 12px; }
            
            #menu-screen { padding: 20px; }
            h1 { font-size: 42px; }
            .subtitle { font-size: 18px; margin-bottom: 30px; }
            button { padding: 15px 40px; font-size: 22px; }
            #result-overlay { font-size: 32px; }
            
            #mobile-controls { display: block; }
            
            /* 手機端：保持 3x3 網格布局，空按鈕透明無邊框但保留占位 */
            .control-btn.empty {
                background: transparent !important;
                border: none !important;
                backdrop-filter: none !important;
                box-shadow: none !important;
                opacity: 0 !important;
                pointer-events: none !important;
            }
        }

        @media (max-width: 480px) {
            h1 { font-size: 36px; }
            .subtitle { font-size: 16px; }
            button { padding: 12px 30px; font-size: 18px; }
            
            /* 小螢幕：進一步往上移動 */
            #input-zone { bottom: 220px; }
            .key-box { width: 40px; height: 40px; font-size: 20px; gap: 8px; }
            
            #preview-container { bottom: 220px; }
            
            .control-pad { width: 180px; gap: 6px; }
            .control-btn { width: 55px; height: 55px; font-size: 24px; }
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="header-info">
            <div>
                <div class="label">Height</div>
                <div style="font-size:32px; font-weight:bold; color:white"><span id="height-display">0.0</span>m</div>
            </div>
        </div>
        <div id="input-zone">
            <div id="current-row-container">
                <div style="font-size:11px; color:#ccc; letter-spacing:1px;">SEQUENCE</div>
                <div id="current-row"></div>
            </div>
        </div>
        <div id="preview-container">
            <div class="label" style="font-size:10px">Next</div>
            <div id="preview-row"></div>
        </div>
    </div>

    <!-- 手機端虛擬方向鍵 -->
    <div id="mobile-controls">
        <div class="control-pad">
            <div class="control-btn empty"></div>
            <div class="control-btn" data-key="ArrowUp">↑</div>
            <div class="control-btn empty"></div>
            <div class="control-btn" data-key="ArrowLeft">←</div>
            <div class="control-btn empty"></div>
            <div class="control-btn" data-key="ArrowRight">→</div>
            <div class="control-btn empty"></div>
            <div class="control-btn" data-key="ArrowDown">↓</div>
            <div class="control-btn empty"></div>
        </div>
    </div>

    <div id="menu-screen">
        <h1>Speed Record</h1>
        <div class="subtitle">15m Official Route</div>
        <div id="result-overlay"></div>
        <p id="status-text" style="font-size: 18px; color: #ccc; margin-bottom: 30px;">READY TO CLIMB?</p>
        <button id="start-btn">START</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const IFSC_SPECS = {
            wallHeight: 15,
            panelSize: 1.5,
            gridSpacing: 0.125,
            overhangAngle: 5 * (Math.PI / 180),
            colors: { sky: 0x87CEEB, wall: 0x808080, hold: 0xff0000, floor: 0x333333 }
        };

        const OFFICIAL_ROUTE_DATA = [
            { t:'foot', p:'DX', pi:1, c:'G', r:4 }, { t:'foot', p:'DX', pi:1, c:'B', r:10 },
            { t:'hand', p:'DX', pi:2, c:'D', r:3 }, { t:'hand', p:'DX', pi:2, c:'E', r:5 },
            { t:'hand', p:'DX', pi:2, c:'C', r:10 }, { t:'hand', p:'SN', pi:3, c:'G', r:4 },
            { t:'hand', p:'SN', pi:3, c:'I', r:8 }, { t:'hand', p:'DX', pi:4, c:'D', r:3 },
            { t:'hand', p:'SN', pi:4, c:'L', r:10 }, { t:'hand', p:'DX', pi:5, c:'C', r:6 },
            { t:'hand', p:'DX', pi:5, c:'H', r:9 }, { t:'hand', p:'SN', pi:6, c:'E', r:2 },
            { t:'hand', p:'SN', pi:6, c:'F', r:9 }, { t:'hand', p:'SN', pi:7, c:'A', r:5 },
            { t:'hand', p:'SN', pi:7, c:'E', r:8 }, { t:'hand', p:'SN', pi:8, c:'L', r:1 },
            { t:'hand', p:'SN', pi:8, c:'I', r:3 }, { t:'hand', p:'SN', pi:8, c:'C', r:8 },
            { t:'hand', p:'SN', pi:9, c:'M', r:10 }, { t:'hand', p:'DX', pi:9, c:'C', r:4 },
            { t:'hand', p:'DX', pi:9, c:'E', r:9 }, { t:'finish', p:'DX', pi:10, c:'B', r:9 }
        ];

        const colMap = char => char.charCodeAt(0) - 65;

        class ClimbingGame {
            constructor() {
                this.container = document.getElementById('canvas-container');
                
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(IFSC_SPECS.colors.sky);
                this.scene.fog = new THREE.Fog(IFSC_SPECS.colors.sky, 15, 60);
                
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(2, -3, 12);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                this.wallGroup = null;
                this.playerGroup = null;
                this.clouds = [];
                this.limbs = {};
                this.rope = null;
                this.timerScreen = null;
                this.timerTexture = null;
                this.timerContext = null;

                this.routeHolds = [];
                this.generatedSequence = [];
                this.currentIndex = 0;
                this.startTime = 0;
                this.finalTime = "0.000";
                this.isPlaying = false;
                this.isRappelling = false;
                this.targetY = 0;
                this.maxPlayerY = 0; 

                this.ui = {
                    height: document.getElementById('height-display'),
                    row: document.getElementById('current-row'),
                    rowContainer: document.getElementById('current-row-container'),
                    preview: document.getElementById('preview-row'),
                    menu: document.getElementById('menu-screen'),
                    status: document.getElementById('status-text'),
                    startBtn: document.getElementById('start-btn'),
                    inputZone: document.getElementById('input-zone'),
                    resultOverlay: document.getElementById('result-overlay'),
                    mobileControls: document.getElementById('mobile-controls')
                };

                this.initScene();
                this.addEvents();
                
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initScene() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 1.1);
                sun.position.set(20, 40, 30);
                sun.castShadow = true;
                this.scene.add(sun);

                this.createClouds();
                this.createEnvironment();
                this.createTimerScreen();
                this.createPlayer();
                this.createRope();
                this.processRoute();
                this.generateInputs();
            }

            createTimerScreen() {
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 128;
                this.timerContext = canvas.getContext('2d');
                this.timerTexture = new THREE.CanvasTexture(canvas);
                this.updateTimerDisplay("0.000");

                const geo = new THREE.BoxGeometry(1.5, 0.4, 0.1);
                const matCase = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const matScreen = new THREE.MeshStandardMaterial({ 
                    map: this.timerTexture, emissive: 0xff0000, 
                    emissiveMap: this.timerTexture, emissiveIntensity: 1.0
                });
                this.timerScreen = new THREE.Mesh(geo, [matCase, matCase, matCase, matCase, matScreen, matCase]);
                this.timerScreen.position.set(0, IFSC_SPECS.wallHeight + 0.4, 0.15);
                this.wallGroup.add(this.timerScreen);
            }

            updateTimerDisplay(text) {
                if(!this.timerContext) return;
                const ctx = this.timerContext;
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 512, 128);
                ctx.font = 'bold 100px Courier New';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 256, 64);
                this.timerTexture.needsUpdate = true;
            }

            createRope() {
                const material = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 2 });
                const points = [new THREE.Vector3(0, IFSC_SPECS.wallHeight + 1, 0.3), new THREE.Vector3(0,0,0)];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.rope = new THREE.Line(geometry, material);
                this.scene.add(this.rope);
            }

            updateRope() {
                if(!this.rope || !this.playerGroup) return;
                const positions = this.rope.geometry.attributes.position.array;
                const wallTopY = IFSC_SPECS.wallHeight + 0.5;
                const rad = IFSC_SPECS.overhangAngle;
                const topY = wallTopY * Math.cos(rad) - 0.2 * Math.sin(rad);
                const topZ = wallTopY * Math.sin(rad) + 0.2 * Math.cos(rad);

                positions[0] = 0; positions[1] = topY; positions[2] = topZ;
                positions[3] = this.playerGroup.position.x;
                positions[4] = this.playerGroup.position.y + 1.0;
                positions[5] = this.playerGroup.position.z + 0.1;
                this.rope.geometry.attributes.position.needsUpdate = true;
            }

            createEnvironment() {
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), new THREE.MeshStandardMaterial({ color: IFSC_SPECS.colors.floor, roughness: 0.8 }));
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                this.wallGroup = new THREE.Group();
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(3.0, IFSC_SPECS.wallHeight + 1, 0.2), 
                    new THREE.MeshStandardMaterial({ color: IFSC_SPECS.colors.wall, roughness: 0.9 })
                );
                wall.position.y = IFSC_SPECS.wallHeight / 2;
                wall.receiveShadow = true;
                this.wallGroup.add(wall);
                this.wallGroup.rotation.x = -IFSC_SPECS.overhangAngle;
                this.scene.add(this.wallGroup);
            }

            createClouds(){
                const cloudGeo = new THREE.IcosahedronGeometry(1, 0);
                const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, flatShading: true });
                for(let i=0; i<15; i++) {
                    const cloud = new THREE.Group();
                    for(let j=0; j<4; j++) {
                        const m = new THREE.Mesh(cloudGeo, cloudMat);
                        m.position.set((Math.random()-0.5)*2,(Math.random()-0.5)*1.5,(Math.random()-0.5)*1.5);
                        m.scale.setScalar(0.8+Math.random());
                        cloud.add(m);
                    }
                    cloud.position.set((Math.random()-0.5)*60, Math.random()*25+5, -20);
                    cloud.userData = { speed: 0.03+Math.random()*0.08 };
                    this.scene.add(cloud);
                    this.clouds.push(cloud);
                }
            }

            createTomahawkHold(isHand) {
                const mat = new THREE.MeshStandardMaterial({ color: IFSC_SPECS.colors.hold, roughness: 0.5 });
                const group = new THREE.Group();
                if (isHand) {
                    const core = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.14, 0.06, 12), mat);
                    core.rotation.x = Math.PI/2; group.add(core);
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.35, 0.08), mat));
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.08), mat));
                    group.scale.setScalar(1.3);
                } else {
                    const btn = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.04, 16), mat);
                    btn.rotation.x = Math.PI/2; group.add(btn);
                }
                group.castShadow = true; group.receiveShadow = true;
                return group;
            }

            processRoute() {
                OFFICIAL_ROUTE_DATA.forEach((item) => {
                    let xPos = ((item.p==='SN'?-1.5:0) + colMap(item.c)*0.125 + 0.125);
                    let yPos = (item.pi-1)*1.5 + (item.r-1)*0.125 + 0.125;
                    const hold = this.createTomahawkHold(item.t==='hand'||item.t==='finish');
                    hold.position.set(xPos, yPos, 0.11);
                    hold.rotation.z = Math.random()*6;
                    this.wallGroup.add(hold);
                    if (item.t === 'finish') {
                        const btn = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.4), new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0xaa8800}));
                        btn.position.set(xPos, yPos - 0.05, 0.15);
                        btn.rotation.x = Math.PI/2;
                        this.wallGroup.add(btn);
                        this.maxPlayerY = yPos - 1.785;
                    }
                    this.routeHolds.push({ x: xPos, y: yPos, type: item.t });
                });
            }

            createPlayer() {
                this.playerGroup = new THREE.Group();
                const matSkin = new THREE.MeshStandardMaterial({ color: 0xffccaa });
                const matSuit = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const matTop = new THREE.MeshStandardMaterial({ color: 0xff4d4d });
                
                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.65, 0.25), matTop);
                torso.position.y = 1.3; this.playerGroup.add(torso);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.25), matSkin);
                head.position.y = 1.8; this.playerGroup.add(head);

                const createLimb = (w, h, x, y, name, mat) => {
                    const g = new THREE.Group();
                    const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.18), mat);
                    m.position.y = -h/2; g.add(m); g.position.set(x, y, 0);
                    this.playerGroup.add(g); this.limbs[name] = g;
                };
                createLimb(0.12, 0.5, -0.28, 1.6, 'LA', matSkin);
                createLimb(0.12, 0.5, 0.28, 1.6, 'RA', matSkin);
                createLimb(0.15, 0.65, -0.15, 1.0, 'LL', matSuit);
                createLimb(0.15, 0.65, 0.15, 1.0, 'RL', matSuit);
                
                this.limbs.LA.rotation.z = 2.5; this.limbs.RA.rotation.z = -2.5;
                this.playerGroup.scale.setScalar(0.85);
                this.playerGroup.position.set(0, 0, 0.5);
                this.playerGroup.rotation.x = -IFSC_SPECS.overhangAngle;
                this.scene.add(this.playerGroup);
            }

            generateInputs() {
                this.generatedSequence = [];
                const keys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
                for(let i=0; i<20; i++) this.generatedSequence.push(keys[Math.floor(Math.random()*keys.length)]);
            }

            startGame() {
                this.currentIndex = 0;
                this.playerGroup.position.set(0, 0, 0.5);
                this.targetY = 0;
                this.isPlaying = true;
                this.isRappelling = false;
                this.ui.menu.style.display = 'none';
                this.ui.inputZone.style.opacity = 1;
                this.ui.resultOverlay.style.display = 'none';
                document.getElementById('preview-container').style.opacity = 1;
                if(this.ui.mobileControls) this.ui.mobileControls.classList.add('active');
                
                this.startTime = Date.now();
                this.renderUI();
                
                if(this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    if(this.isPlaying) {
                        const t = ((Date.now() - this.startTime)/1000).toFixed(3);
                        this.updateTimerDisplay(t);
                    }
                }, 33);
            }

            finishClimb() {
                this.isPlaying = false;
                clearInterval(this.timerInterval);
                this.finalTime = ((Date.now() - this.startTime)/1000).toFixed(3);
                this.updateTimerDisplay(this.finalTime);

                this.ui.inputZone.style.opacity = 0;
                document.getElementById('preview-container').style.opacity = 0;
                if(this.ui.mobileControls) this.ui.mobileControls.classList.remove('active');

                // Wait 0.5s then start sliding down
                setTimeout(() => {
                    this.startRappel();
                }, 500);
            }

            startRappel() {
                this.isRappelling = true;
                this.limbs.LA.rotation.z = 0.2;
                this.limbs.RA.rotation.z = -0.2;
                this.limbs.LL.rotation.x = 0;
                this.limbs.RL.rotation.x = 0;
            }

            showMenu() {
                this.ui.status.innerHTML = `COMPLETED IN <span style="color:#ffdf00; font-size:32px">${this.finalTime}s</span>`;
                this.ui.resultOverlay.innerHTML = this.finalTime;
                this.ui.resultOverlay.style.display = 'block';
                this.ui.startBtn.innerText = "CLIMB AGAIN";
                this.ui.menu.style.display = 'flex';
                this.isRappelling = false;
            }

            addEvents() {
                this.ui.startBtn.addEventListener('click', () => this.startGame());
                
                // 鍵盤事件
                window.addEventListener('keydown', (e) => {
                    if(!this.isPlaying) return;
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) {
                        this.handleKeyInput(e.code);
                    }
                });
                
                // 手機端觸控按鈕
                const controlBtns = document.querySelectorAll('.control-btn[data-key]');
                controlBtns.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if(!this.isPlaying) return;
                        const key = btn.getAttribute('data-key');
                        this.handleKeyInput(key);
                    });
                    btn.addEventListener('touchend', (e) => e.preventDefault());
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        if(!this.isPlaying) return;
                        const key = btn.getAttribute('data-key');
                        this.handleKeyInput(key);
                    });
                });
                
                // 防止手機端滾動和縮放
                document.addEventListener('touchmove', (e) => {
                    if(this.isPlaying) e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchstart', (e) => {
                    if(e.target.closest('#mobile-controls') || e.target.closest('#menu-screen')) {
                        return; // 允許控制按鈕和菜單的觸控
                    }
                }, { passive: true });
            }
            
            handleKeyInput(keyCode) {
                if(!this.isPlaying) return;
                if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(keyCode)) {
                    if(keyCode === this.generatedSequence[this.currentIndex]) {
                        this.handleSuccess();
                    } else {
                        this.playerGroup.position.x += (Math.random()-0.5)*0.3;
                        this.ui.rowContainer.style.transform = "translateX(5px)";
                        setTimeout(()=>this.ui.rowContainer.style.transform = "translateX(0)", 50);
                    }
                }
            }

            handleSuccess() {
                this.markKeyDone(this.currentIndex);
                this.currentIndex++;
                
                const ratio = this.currentIndex / this.generatedSequence.length;
                this.targetY = ratio * this.maxPlayerY;

                if(this.currentIndex % 5 === 0) {
                    this.renderUI();
                } else {
                    // 更新 preview（即使不在頁面切換時）
                    this.updatePreview();
                }

                const t = this.currentIndex % 2 === 0;
                this.limbs.LA.rotation.z = t ? 2.8 : 0.5;
                this.limbs.RA.rotation.z = t ? 0.5 : -2.8;
                this.limbs.LL.rotation.x = t ? 0.8 : 0;
                this.limbs.RL.rotation.x = t ? 0 : 0.8;

                if (this.currentIndex >= this.generatedSequence.length) {
                    this.finishClimb();
                }
            }

            updatePreview() {
                const CHUNK = 5;
                const page = Math.floor(this.currentIndex / CHUNK);
                const end = (page + 1) * CHUNK;
                this.ui.preview.innerHTML = '';
                const nextSlice = this.generatedSequence.slice(end, end+CHUNK);
                if(nextSlice.length > 0) {
                    nextSlice.forEach(key => {
                        const d = document.createElement('div'); d.className = 'preview-key';
                        d.innerText = {'ArrowUp':'↑','ArrowDown':'↓','ArrowLeft':'←','ArrowRight':'→'}[key];
                        this.ui.preview.appendChild(d);
                    });
                    document.getElementById('preview-container').style.opacity = 1;
                } else {
                    document.getElementById('preview-container').style.opacity = 0;
                }
            }

            renderUI() {
                const CHUNK = 5; const page = Math.floor(this.currentIndex / CHUNK);
                const start = page * CHUNK; const end = start + CHUNK;
                this.ui.row.innerHTML = '';
                this.generatedSequence.slice(start, end).forEach((key, i) => {
                    const div = document.createElement('div');
                    div.className = 'key-box';
                    div.innerText = {'ArrowUp':'↑','ArrowDown':'↓','ArrowLeft':'←','ArrowRight':'→'}[key];
                    div.id = `key-${start+i}`;
                    if(start+i < this.currentIndex) div.classList.add('done');
                    else if(start+i === this.currentIndex) div.classList.add('active');
                    this.ui.row.appendChild(div);
                });
                this.updatePreview();
            }
            markKeyDone(idx) {
                const el = document.getElementById(`key-${idx}`);
                if(el) { el.classList.remove('active'); el.classList.add('done'); }
                const next = document.getElementById(`key-${idx+1}`);
                if(next) next.classList.add('active');
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                if(this.playerGroup) {
                    if (this.isRappelling) {
                        // --- SLOW SMOOTH RAPPEL ---
                        this.playerGroup.position.y -= 0.04; // Reduced speed for smooth sliding
                        
                        // Slight swing out
                        this.playerGroup.position.z = 1.5;
                        this.playerGroup.rotation.x = 0; 

                        // Camera follow descent
                        this.camera.position.y = this.playerGroup.position.y + 2;
                        this.camera.lookAt(0, this.playerGroup.position.y + 1, 0);

                        if(this.playerGroup.position.y <= 0) {
                            this.playerGroup.position.y = 0;
                            this.showMenu();
                        }
                    } else {
                        this.playerGroup.position.y += (this.targetY - this.playerGroup.position.y) * 0.15;
                        
                        if(this.isPlaying) {
                            if(this.currentIndex < this.generatedSequence.length) {
                                const progress = this.currentIndex / this.generatedSequence.length;
                                const hIdx = Math.floor(progress * this.routeHolds.length);
                                const hold = this.routeHolds[Math.min(hIdx, this.routeHolds.length-1)];
                                this.playerGroup.position.x += (hold.x - this.playerGroup.position.x) * 0.08;
                            }
                            const camY = Math.min(this.playerGroup.position.y + 2, 15.5);
                            this.camera.position.y += (camY - this.camera.position.y) * 0.1;
                            this.camera.lookAt(0, this.playerGroup.position.y + 4, -5);
                        } else {
                            // Look at timer
                            const finishCamY = IFSC_SPECS.wallHeight - 1; 
                            this.camera.position.y += (finishCamY - this.camera.position.y) * 0.05;
                            this.camera.lookAt(0, IFSC_SPECS.wallHeight + 1, 0);
                        }
                    }

                    this.updateRope();
                    this.ui.height.innerText = Math.max(0, Math.min(this.playerGroup.position.y, 15.0)).toFixed(1);
                }

                this.clouds.forEach(c => {
                    c.position.x += c.userData.speed;
                    if(c.position.x > 40) c.position.x = -40;
                });

                this.renderer.render(this.scene, this.camera);
            }
        }

        new ClimbingGame();
    </script>
</body>
</html>